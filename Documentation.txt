/**

<!--==========================================================================================-->

\page IDE_FOR_ESP32 Installer l'IDE Arduino pour l'ESP32

L'aide pour l'installation du support ESP32 par l'IDE Arduino est disponible sur le site suivant
<a href="https://www.upesy.fr/blogs/tutorials/install-esp32-on-arduino-ide-complete-guide" 
   target="_blank" rel="noopener">Installer l'IDE Arduino pour l'ESP32</a> 

## Problème de time-Out

Il peut arriver qu'une mise à jour ne puisse se termimer.<BR>
Cela est du à un paquet dont le temps de chargement dépasse le time-out par défaut.

Pour modifier le time-out de chargement des paquets de logiciel dans l'IDE Arduino :

- Fermer l'IDE Arduino
- Ouvrir le fichier : **C:\\Users\\\<username\>\\.arduinoIDE\\arduino-cli.yaml**
- Ajouter les lignes suivantes

```yaml
network:
  connection_timeout: 300s
```

## Problème avec Serial

Lors d'affichage de trace dans le moniteur de l'IDE Arduino, au  bout d'un certain temps l'affichage se bloque.

Pour corriger ce problème :

- Ouvrir le fichier **C:\\Users\\\<username\>\\AppData\\Local\\Arduino15\\packages\\esp32\\hardware\\esp32\\3.3.5\\boards.txt**
- Remplacer les lignes

```
esp32s2.serial.disableDTR=false
esp32s2.serial.disableRTS=false
```

- par

```
esp32s2.serial.disableDTR=true
esp32s2.serial.disableRTS=true
```


## Problème alors de la compilation

Il peut arriver que la génération du logiciel ne finissent pas lors de l'édition de lien car elle utilise des fichiers de type **.o** qui ne sont plus les bons

Pour régler le problème, il faut supprimer un répertoire dans le répertoire **sketches** :
**C:\\Users\\\<username\>\\AppData\\Local\\arduino\\sketches**

Le nom du répertoire est par exemple **1D28B4FA3FD80E921A8889962A5655DB**

Pour identifier le répertoire à supprimer, regarder le plus récent

Ce répertoire permet de conserver en mémoire une partie de la dernière compilation pour gagner du temps sur la prochaine.<BR>
Il n'y a donc aucun risque à supprimer un mauvais répertoire. <BR>
Au pire, la prochaine compilation sera plus longue.

\todo

<!--==========================================================================================-->

\page DOXYGEN Utilisation de doxygen

Le logiciel **doxygen** est utilisé pour générer automatiquement la document du logiciel à partir du code

La documentation de doxygen est disponible sur le site suivant : 
<a href="https://www.doxygen.nl/manual/index.html" target="_blank" rel="noopener">Guide d'utilisation de Doxygen</a> 

La liste des mots clés est disponible sur le site suivant : 
<a href="https://www.doxygen.nl/manual/commands.html" target="_blank" rel="noopener">Liste des mots clés</a> 


TODO Expliquer coment installer et utiliser DOXYGEN

<!--==========================================================================================-->

\page RADIOHEAD Librairie RadioHead pour la gestion du 433MHz

La librairie en charge de la gestion 433Mhz est la librairie **RadioHead par Mike McCauley**

Elle est disponible <a href="https://www.airspayce.com/mikem/arduino/RadioHead/RadioHead-1.142.zip">ICI</a> 

Il faut dézipper le contenu et le copier dans le répertoire **Libraries** ou est installlé Arduino

Typiquement dans le répertoire : **C:\\Users\\\<username\>\\Documents\\arduino\\Libraries**

\attention
Il est possible que l'erreur suivante apparaise : **multiple definition of `__vector_17'** <BR>
Il est alors nécessaire de modifier le fichier **RH_ASK.cpp** pour éviter les incompatibilités avec la librairie 'servo' <BR>
Remplacer la ligne <BR>
```
//#define RH_ASK_ARDUINO_USE_TIMER2
```
par
```
#ifdef AVR
#define RH_ASK_ARDUINO_USE_TIMER2
#endif
```
Il est nécessaire de refaire ce changement à chaque mise à jour de la librairie RadioHead


<!--==========================================================================================-->

\page ESP32_SPECIFIC Spécificités de l'ESP32

L'utilisation de l'ESP32 dans un contexte IDE Arduino peut nécessiter quelques adaptations

# Code spécifique à l'ESP32

Des portions de codes peuvent être différents entre un Arduino et un ESP32.



Il est alors nécessaire de spécifier les différentes portion de code de la manière suivante:

```
  #ifdef AVR
	
    CODE SPECIFIQUE ARDUINO
	
  #endif
  #ifdef ARDUINO_ARCH_ESP32
  
    CODE SPECIFIQUE ESP32
	
  #endif
```

# Mise en oeuvre d'une sortie PWM

Pour un Arduino, la génération d'un signal PWM se fait
- en déclarant la sortie en mode OUTPUT : pinMode(pin, OUTPUT)
- en écrivant une valeur entre 0 et 1023 : analogWrite(pin,valeur)

Pour un ESP32, il faut utiliser la librairie ledc pour déclarer la sortie en mode PM
- en déclarant la sortie en mode analogique : ledcAttach(pin,1000,10)
- en écrivant une valeur entre 0 et 1023 : analogWrite(pin,valeur)

Plus d'information sur le site suivant : 
<a href="https://docs.espressif.com/projects/arduino-esp32/en/latest/api/ledc.html" target="_blank" rel="noopener">Librairie LEDC</a>

\warning Le nombre de canaux PWM est limité à 8 pour un ESP32-S2,
Il est donc nécessaire de connaitre le nombre de canaux PWM utilisé au total <BR>
Par exemple la librairie \ref LibMoteur utilise jusqu'à 2 canaux PWM

<!--==========================================================================================-->

\page USE_LIBRARY Utilisation de la librairie LibLaboCesson

La librairie **LibLaboCesson** permet de faciliter le développement des robots et PAMI
en proposant une interface de contrôle des différents éléments le constituant

La Librairie est composée de deux types de classes :
 - Des classes _**basiques**_ permettant de gérer un composant (par exemple la classe \ref LibAff1637 pour gérer un afficheur 7 Segments)
 - Des classes _**robot**_ permettant de gérer l'ensemble des composants d'un robot (par exemple \ref LibPami2026Basic gère un PAMI basique du concours 2026)

Les classes _**basiques**_ sont génériques et peuvent être utilisées dans un contexte quelconque. <BR>
Les classes _**robots**_  utilisent les classes _**basiques**_ correspondant aux éléments du robot
et définit le cas échéant les pins et interfaces associés à chaque éléments

Par exemple la classe \ref LibAff1637 permet de connecter l'afficheur sur n'importe quel port. <BR>
Mais une classe _**robots**_  appelera la classe \ref LibAff1637 en définissant à quel port l'afficheur est connecté <BR>
L'afficheur sera alors utilisable en utilisant par exemple un appel du type _**pami2026basique.afficheur.displayValue(10)**_

Par exemple, la classe LibPami2026Basic est composée des librairies suivantes :
- \ref LibJumper pour indiquer au PAMI qui il est et à quelle équipe il appartient
- \ref Lib433Mhz pour permettre de recevoir l'ordre de début de la manche
- \ref LibChrono pour gérer le temps d'attente avant de partir vers un nid
- \ref LibMoteurS pour faire avancer le PAMI
- \ref LibGyroscope pour lui permettre de suivre une direction
- \ref LibGpio pour gérer le servomoteur du dessus


Les classes _**robots**_ gérent l'ensemble des éléments d'un robot,
mais ils ne sont pas les logiciels finaux des robots.
Les différents éléments accessibles par une classe de type _**robot**_ seront utilisées pour par exemple :
 - Attendre un ordre de départ (par exemple avec la librairie \ref LibAff1637)
 - Faire avancer le robot (par exemple avec la librairie \ref LibMoteur)
 - S'assurer que le robot va droit (par exemple avec la librairie \ref LibGyroscope)


TODO


<!--==========================================================================================-->

\page GIT Utilisation de GIT

Créer un repository sur GitHub (Par exemple "MyProject")


```
echo "# MyProject" >> README.md
git init
git add README.md
git commit -m "first commit"
git branch -M main
git remote add origin https://github.com/LaboCesson/MyProject.git
git push -u origin main
```

TODO


<!--==========================================================================================-->

\page BUSCAN Le BUS CAN

# Introduction

## Description du bus CAN
Le Bus CAN est une technologie utilisée dans ledomaine automobile pour echanger des informations entre les différents organes de la voiture.<BR>
Il est utilisé par le Labo Cesson pour échanger des informations entre le poste de pilotage et le robot

## Implémentation matérielle

Le bus CAN est mis en oeuvre en utilisant le 
<a href="https://handsontec.com/dataspecs/module/Networking/MCP2515%20CAN%20Module.pdf" target="_blank" rel="noopener">Module MCP2515</a>

Ce module a une horloge à 8Mhz qui limite le débit mais est largement suffisant car autorise un débit de 125Kbits/sec.

Ce qui permet typiquement d'échanger d'échanger théoriquement plus de 1000 messages par seconde.

Dans l'implémentation actuelle, la librairie utilisée est la librairie 
<a href="https://github.com/Seeed-Studio/Seeed_Arduino_CAN" target="_blank" rel="noopener">CAN_BUS_Shield par Seed Studio</a>

Le module 
<a href="https://fr.pinterest.com/pin/usb-liltech-canable-plildebugger-outil-de-dbogage-lilbus-pour-linux-win10-11-typec-usb-degraine-in-2025--4593742097083648000/" target="_blank" rel="noopener">
USB LilTech, CANable PLilDebugger Outil de débogage Lilbus</a>
 avec le logiciel 
<a href="https://www.peak-system.com/Software.68.0.html" target="_blank" rel="noopener">PCAN-View</a>


# Description du protocole

## Format général

Le protocole est du type commande/réponse.
Une nouvelle commande ne peut être envoyée que lorsque la réponse à la précédente a été reçue.

Le protocole est décrit dans le fichier \ref LibCanProtDef.h

Une commande est composée des octets suivants:

- un MagicTag (0xC7) permettant de s'assurer que l'on a bien le début d'une commande ou d'une réponse<BR>
  Le cas échéant, en cas de désynchronisation, il pourrait être possible d'effecteur une resynchronisation<BR><BR>
- une Commande/Réponse avec le bit de poids fort à 0 pour une commande et à 1 pour une réponse<BR>
  Cela autorise jusqu'à 128 commandes différentes<BR>
  Le code de la réponse est égale au code de la commande<BR><BR>
- Le nombre d'octets suivant cet octet<BR>
  La longueur maximum d'une commande est de \ref BUS_CAN_MESSAGE_MAX_SIZE octets, ce nombre ne doit donc pas excéder cette valeur diminuée de 3<BR><BR>
- Les données associées à la commande dont le nombre et le rôle dépendent de la commande

\warning Une réponse utilise le même code que la commande associée ce qui permet de s'assurer que l'on est bien synchronisé.
Mais si l'on envoi de manière continue la même commande, il peut y avoir une désynchronisation jusqu'à l'envoi d'une commande différente

## Description des commandes

Il existe deux types de commandes:

- Des commandes permettant d'adresser directement le matériel de la carte Robot<BR>
  Par exemple, la commande BUS_CAN_SET_PIN_DIGITAL permet de gérer directement un port en utilisant son numéro de pin
- Des commandes utlisant un niveau d'abstraction et permettant de gérer un organe de la carte Robot<BR>
  Par exemple, la commande BUS_CAN_SET_RELAY peremt de gérer l'état d'un relai sans connaitre le port qui lui est associé<BR>

Les commandes avec un niveau d'abstraction permettent d'avoir des logiciels de contrôle indépendants de la carte présente sur la carte Robot<BR>
Par exemple, le logiciel de gestion du joystick s'appuie sur la commande BUS_CAN_SET_MOTEUR_1 et est identique pour les deux robots,
bien que l'un soit équipé d'une carte Arduino Mega Mini et l'autre d'un ESP32-S2

Les commandes sont décrites dans le fichier \ref LibCanProtDef.h


# Implémentation logicielle

## Organisation des classes

L'ensemble des classes gérant le bus CAN sont présentes dans les fichiers 

- \ref LibCan.h qui contient la définition des classes
- \ref LibCanProtDef.h qui contient la définition des commandes
- \ref LibCan.cpp qui contient l'implémentation des classes

Il existe 4 classes :

- la classe \ref LibCan2515 qui permet de gérer les couches basses du bus CAN
  Initialisation du matériel, envoi d'un message, lecture d'un message
- la classe \ref LibCanProtSend qui est utilisée par le logiciel pilote pour envoyer des commandes et lire des réponses
- la classe \ref LibCanProtRecv qui est utilisé par le robot pour lire des commandes, les exécuter et retoourner une réponse
- la classe \ref LibCanProtCommon qui contient des fonctions communes aux deux classes \ref LibCanProtSend et \ref LibCanProtRecv


## Mise en oeuvre de la classe LibCanProtSend

La classe \ref LibCanProtSend est générique et à besoin de connaitre l'objet en charge de la gestion des couches basses<BR>
Une initialisation typique est donc la suivante :

```
#include "LibCan.h"
#define CAN_BUS_CS_PIN 49

LibCan2515     canBus(CAN_BUS_CS_PIN);
LibCanProtSend canProt;
```

Puis dans le setup(), il faut donner à l'objet canProt la référence de l'objet canBus

```
canProt.setCanBusDriver(&canBus);
bool status = canProt.begin();
```

Ensuite, l'envoi des commandes se fait en utilisant les commandes du type ```canProt.sendSetxxx(xxx)```<BR>
Par exemple la commande ```canProt.sendSetRelay(2,HIGH)``` permet d'activer le relai n°2 du robot


## Mise en oeuvre de la classe LibCanProtRecv

La classe \ref LibCanProtRecv est aussi générique et à besoin de connaitre l'objet en charge de la gestion des couches basses,
mais aussi des objets en charge de la gestion des éléments du robot (moteur, GPIO, détecteur de couleur, ...)<BR>


Une initialisation typique est donc la suivante :

```
#include "LibCan.h"
#define CAN_BUS_CS_PIN 49

LibCan2515     canBus(CAN_BUS_CS_PIN);
LibCanProtSend canProt;

#include "LibMoteur.h"
LibMoteur  moteur1(1,2, 3, 4, 5,6);

#include "LibColor.h"
LibTcs3472 color;

#include "LibGpio.h"
LibGpio gpio(gpioPinRobotTeamB, nbGpioRobotTeamB);
```


Puis dans le setup(), il faut donner à l'objet canProt la référence des différents objets

```
	canProt.setCanBusDriver(&canBus);
	bool status = canProt.begin();
	canProt.setMoteurDriver(0,&moteur1);
	canProt.setColorDriver(&color);
	canProt.setGpioDriver(&gpio);
```

La fonction ```canProt.gestionMessage()``` gère l'ensemble des commandes
et s'appuie sur les objets passés en référence pour les exécutées.<BR>
La fonction ```loop()``` devient simplement la suivante :

```
void loop(void){
  color.gestion();
  canProt.gestionMessage();
}
```

A noter la présence de l'appel à la fonction gestion de l'objet color.
En effet l'objet color nécessite un appel régulier pour être opérationnel


*/